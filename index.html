<!DOCTYPE html>
<!-- <html class="no-js" lang="en"  manifest="hotpi.manifest" > -->
<html class="no-js" lang="en" >
<head>
  <meta charset="UTF-8">
   <!-- Use minimum-scale=1 to enable GPU rasterization -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, user-scalable=0, maximum-scale=1, minimum-scale=1">
  <title>Moberlinity</title>

  
   <style>
    body { 
      margin: 0;
      padding: 0; 
    }
    path {
      pointer-events: none
    }
    #app { 
      position: absolute;
      height: 100%;
      top: 51;
      bottom: 0;
      width: 100%;
    }
    .leaflet-container {
      cursor: default;
    }
    .leaflet-marker-icon {
      cursor: default;
    }
    .leaflet-marker-draggable:hover{
      cursor: -webkit-grab;
    }
    .leaflet-marker-draggable:active{
      cursor: -webkit-grabbing;
    }
    .distance-icon {
      border-radius: 10px;
      background: #fff;
      color: #1a25b9;
      text-align: center;
      font-size: 9px;
      display: inline-block;
      border: 2px solid #1a25b9;
    }

    .initializer {
      height: 40px; 
      width: 200px; 
      position: fixed; 
      background: #16c8ce;
      text-transform: uppercase; 
      color: white;
      border-radius: 2px;
      font-size: 16px;
      border: 0px #12a3a5;
      bottom: 0; 
      right: 0; 
      margin-bottom: 60px; 
      margin-right: 60px; 
      z-index: 1000
     -webkit-box-shadow: 10px 7px 14px 6px rgba(87,83,87,0.87);
      -moz-box-shadow: 10px 7px 14px 6px rgba(87,83,87,0.87);
      box-shadow: 10px 7px 14px 6px rgba(87,83,87,0.87);
    }
   </style>

</head>
<body>
<div id="app"></div>
<button onclick="run()" class="initializer"> Start simulation</button>
  
<script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
<script src='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.css' rel='stylesheet' />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>

<link href='https://www.mapbox.com/base/latest/base.css' rel='stylesheet' />

<script> 
  function Vehicle(location, status, battery) {
    this.location = location;
    this.status = status;
    this.battery = battery;
  }

  function Citizen(location, destination) {
    this.location = location;
    this.destination = destination;
  }

  function Place(location) {
    this.location = location;
  }

  function Ride(citizen, vehicle, finalLocation) {
    this.citizen = citizen;
    this.vehicle = vehicle;
    this.initialLocation = initialLocation;
    this.finalLocation = finalLocation;
  }

  let numberOfVehicles;
  let numberOfCitizens;
  let initialCoordenates;
  let map;
  let centralMarker;
  let currentRadius = 5; // kilometers
  let bufferedPoints;
  let onSimulation = false;
  const vehicles = [];
  const places = [];
  const citizens = [];
  const paths = [];
  const rides = [];
  const tripEndingNotification = [];
  const pathColors = [ '#815da6', '#599ba9', '#54bd36', '#530101', '#add5c5', '#919b30', '#cd7d84', '#855c51', '#f011ed', '#b54a71', '#6294e3' ];
  
  (function createMap() {
    L.mapbox.accessToken = 'pk.eyJ1IjoianVhbmVjYWJlbGxvYiIsImEiOiJjajRqdXI1bjEwbnZwMnFvNzlsZDN1MzliIn0.BRkacCy_B0Yvz-6nR8wYuQ';
    map = L.mapbox.map('app').setView([51.505, -0.09], 13);
    L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
      attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
      maxZoom: 18,
      id: 'mapbox.streets',
      accessToken: L.mapbox.accessToken
    }).addTo(map);
    centralMarker = L.marker(new L.LatLng(51.505, -0.09), {
      icon: L.mapbox.marker.icon({
          'marker-color': '#00704A',
          'title': 'Entry point',
          'marker-size': 'large',
          'marker-symbol': 'marker-stroked'
      }),
      draggable: true,
      zIndexOffset: 999
    });
    centralMarker.on('drag', () => {
      drawCircleArea();
    })
    centralMarker.addTo(map);

    map.on('click', onMapClick);
  })();

  //Geocoder lookup
  var geocoder = L.mapbox.geocoder('mapbox.places-v1');
  function getMarkerPoint() {
    const position = centralMarker.getLatLng();
    const point = turf.point([ position.lng, position.lat ])
    return point;
  }

  // creates a buffer of points in circle form
  function pointBuffer(point, radius, resolution, units) {
    let ring = []
    let resMultiple = 360/resolution;
    for (var i = 0; i < resolution; i++) {
      const spoke = turf.destination(point, radius, i*resMultiple, units);
      ring.push(spoke.geometry.coordinates);
    }
    if ((ring[0][0] !== ring[ring.length-1][0]) && (ring[0][1] != ring[ring.length-1][1])) {
      ring.push([ring[0][0], ring[0][1]]);
    }

    return turf.polygon([ring]);
  }

  function resetMap() {
    clearAllTimeouts();
    onSimulation = false;
    map.eachLayer((layer) => {
      console.log(layer)
      if (!_.has(layer, 'url') && (_.has(layer, 'getLatLng') && layer.getLatLng() !== centralMarker.getLatLng())) {
        map.removeLayer(layer);        
      }
    });
    paths.length = 0;
  }

  function drawCircleArea() {
    const point = getMarkerPoint();
    $('path').remove();
    $('.leaflet-marker-pane *').not(':first').remove();

    bufferedPoints = pointBuffer(point, currentRadius, 120, 'kilometers');
    bufferedPoints.properties = {
        'fill': 'blue',
        'fill-opacity': 0.05,
        'stroke': 'blue',
        'stroke-width': 2,
        'stroke-opacity': 0.7
    };
    const bufferLayer = L.mapbox.featureLayer().setGeoJSON(bufferedPoints).addTo(map);
  }

  function run() {
    resetMap();
    prepareSimulation();
    startSimulation();
  }

  function onMapClick(e) {    
    initialCoordenates = [ e.latlng.lat, e.latlng.lng ];
    centralMarker.setLatLng(initialCoordenates);
    map.setView(initialCoordenates, 13);
    drawCircleArea();
  }

  function prepareSimulation() {
    numberOfVehicles = prompt('Please enter the number of vehicles', '30');
    numberOfCitizens = prompt('Please enter the number of citizens', '10');
    generateMarkers(numberOfVehicles, 'vehicles');
    generateMarkers(numberOfCitizens, 'citizens');
    generateMarkers(Math.ceil(Math.random() * (100 - 50)) + 50, 'places');
    onSimulation = true;
  }

  $('.leaflet-marker-draggable').on('mousewheel',function(event){
    let wheelDelta= event.originalEvent.wheelDeltaY;
    if (currentRadius - wheelDelta * 0.001 >= 0.2 && currentRadius - wheelDelta * 0.001 <= 8) {
      currentRadius = currentRadius - wheelDelta * 0.001;
      drawCircleArea();
    }

    event.stopPropagation();
    return false;
  });

 /* function getLocation() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(showPosition);
    }
  }*/

  function generateMarkers(number, type) {
    let featureCollection = turf.random('point', number, {
      bbox: turf.bbox(bufferedPoints)  
    });
    let j = 0;
    insideCircle = turf.within(featureCollection, turf.featureCollection([bufferedPoints]));
    while (insideCircle.features.length < number && j < 50) {
      featureCollection = turf.random('point', number - insideCircle.features.length, {
        bbox: turf.bbox(bufferedPoints)  
      });
      console.log(insideCircle, j)

      insideCircle = turf.featureCollection([
        ...insideCircle.features, 
        ...turf.within(featureCollection, turf.featureCollection([bufferedPoints])).features
      ]);

      console.log(insideCircle, j)
      j ++;
    }
    const featureCollectionInsideCircle = insideCircle;

    turf.featureEach(featureCollectionInsideCircle, (currentFeature) => {
      if (turf.inside(currentFeature, bufferedPoints)) {
        switch (type) {
        case 'vehicles':
          currentFeature.properties['marker-color'] = '#ffe100'
          currentFeature.properties['title'] = `Vehicle at [${currentFeature.geometry.coordinates[0]}, ${currentFeature.geometry.coordinates[1]}]`;
          currentFeature.properties['marker-size'] = 'small';
          currentFeature.properties['marker-symbol'] = 'car';
          vehicles.push(new Vehicle(currentFeature, 'idle', 0))
          break;
        case 'citizens':
          currentFeature.properties['marker-color'] = '#00ff11'
          currentFeature.properties['title'] = `Citizen at [${currentFeature.geometry.coordinates[0]}, ${currentFeature.geometry.coordinates[1]}]`;
          currentFeature.properties['marker-size'] = 'small';
          currentFeature.properties['marker-symbol'] = 'pitch';
          citizens.push(new Citizen(currentFeature, null))
          break;
        case 'places':
          currentFeature.properties['marker-color'] = '#ff0000'
          currentFeature.properties['title'] = `Place at [${currentFeature.geometry.coordinates[0]}, ${currentFeature.geometry.coordinates[1]}]`;
          currentFeature.properties['marker-size'] = 'small';
          places.push(new Place(currentFeature))
          break;
        default:
          break;
        }
      }
    })

    let simulationMarkers = L.mapbox.featureLayer().setGeoJSON(featureCollectionInsideCircle).addTo(map);
    simulationMarkers.on('mouseover', (e) => {
        e.layer.openPopup();
      })
      .on('mouseout', (e) => {
        e.layer.closePopup();
      })
  }

  function simulateRide(citizen, place, iteration) {
    // update destination
    citizen.destination = _.cloneDeep(place.location);
    // citizen.location.properties['title'] = `Citizen at [${citizen.location.geometry.coordinates[0]}, ${citizen.location.geometry.coordinates[1]}] with destination [${citizen.destination.geometry.coordinates[0]}, ${citizen.destination.geometry.coordinates[1]}]`
    const vehicleLocations = vehicles.filter(vehicle => vehicle.status === 'idle').map(vehicle => vehicle.location);

    if (vehicleLocations.length === 0) {
      return false;
    }

    // find nearest vehicle
    const nearestVehicleFeature = turf.nearest(citizen.location, turf.featureCollection(vehicleLocations))
    const nearestVehicleObject = vehicles[vehicleLocations.indexOf(nearestVehicleFeature)];
    
    nearestVehicleObject.status = 'on-the-road';
    // road from his place to vehicle
    const citizenCoordinates = citizen.location.geometry.coordinates;
    const vehicleCoordinates = nearestVehicleFeature.geometry.coordinates;
    let startEnd = citizenCoordinates[0]+','+citizenCoordinates[1]+';'+vehicleCoordinates[0]+','+vehicleCoordinates[1];
    const directionsCitizenVehicleAPI = 'https://api.tiles.mapbox.com/v4/directions/mapbox.walking/'+startEnd+'.json?access_token='+L.mapbox.accessToken;

    $.get(directionsCitizenVehicleAPI, (data) => {
      let coordsAB = data.routes[0].geometry.coordinates;
      coordsAB.unshift(citizenCoordinates);
      coordsAB.push(vehicleCoordinates);

      let totalDuration = data.routes[0].duration;
      const placeCoordinates = place.location.geometry.coordinates;
      startEnd = vehicleCoordinates[0]+','+vehicleCoordinates[1]+';'+placeCoordinates[0]+','+placeCoordinates[1];
      const directionsVehiclePlaceAPI = 'https://api.tiles.mapbox.com/v4/directions/mapbox.driving/'+startEnd+'.json?access_token='+L.mapbox.accessToken;
      $.get(directionsVehiclePlaceAPI, (data) => {
        let coordsBC = data.routes[0].geometry.coordinates;
        coordsBC.unshift(...coordsAB);
        coordsBC.push(placeCoordinates);



        totalDuration = totalDuration + data.routes[0].duration;
        paths.push(turf.lineString(coordsBC, {
          "name": `iteration ${iteration} path`,
          "duration": totalDuration, 
          "stroke": pathColors[iteration],
          "stroke-width": 4,
          "opacity":1
        }));
        L.mapbox.featureLayer()
          .setGeoJSON(turf.featureCollection(paths))
          .on('mouseover', (e) => {
            e.layer.openPopup();
          })
          .on('mouseleave', (e) => {
            e.layer.closePopup();
          })
          .addTo(map);

        let totalDurationParsed = moment.duration(totalDuration, 'seconds').humanize()
        
        L.marker([coordsBC[parseInt(coordsBC.length*0.5)][1],coordsBC[parseInt(coordsBC.length*0.5)][0]],{
          icon: L.divIcon({
              className: 'distance-icon',
              html: `<strong style="color: ${pathColors[iteration]}">${totalDurationParsed}</strong>`,
              iconSize: [60, 23]
          })})
          .addTo(map);
        tripEndingNotification.push(setTimeout(() => {
          console.log('>>>>>>> TRIP CONCLUDED')
          console.log('======================')
          console.log('Citizen moved from ', citizen.location, ' to ', citizen.destination);
          console.log('Nearest vehicle founded at ', nearestVehicleObject.location);
          console.log('======================')
          rides.push(new Ride(_.cloneDeep(citizen), _.cloneDeep(nearestVehicleObject), _.cloneDeep(place)));
          citizen.destination = null;
          citizen.location = place.location;
          nearestVehicleObject.location = place.location;
          nearestVehicleObject.status = 'idle';
        }, totalDuration * 1000));
      });
    });

    return true;
  }

  function clearAllTimeouts() {
    if (tripEndingNotification.length === 0) {
      return;
    }

    tripEndingNotification.map(timeout => clearTimeout(timeout))
    console.log('>>>> All timeouts have been cleared');
    tripEndingNotification.length = 0;
  }

  function startSimulation() {
    let getRandomVehicleIndex = function () { 
      return Math.floor(Math.random() * (vehicles.length))
    };

    let getRandomCitizenIndex = function () {
      return Math.floor(Math.random() * (citizens.length))
    };

    let getRandomPlaceIndex = function () {
      return Math.floor(Math.random() * (places.length))
    };

    for (var i = 0; i < 10; i++) {
      let citizenIndex = getRandomCitizenIndex();
      let citizen = citizens[citizenIndex];
      console.log(citizen, citizenIndex);
      let j = 0;
      try {
        while (citizen.destination !== null && j <= 20) {
          citizenIndex = getRandomCitizenIndex();
          citizen = citizens[citizenIndex];
          j++;
          console.log(citizen, citizenIndex);
        }
      } catch (err) {

      }
      simulateRide(citizens[citizenIndex], places[getRandomPlaceIndex()], i)
    }
  }

  </script>
</body>
</html>
