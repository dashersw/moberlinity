<!DOCTYPE html>
<!-- <html class="no-js" lang="en"  manifest="hotpi.manifest" > -->
<html class="no-js" lang="en" >
<head>
  <meta charset="UTF-8">
   <!-- Use minimum-scale=1 to enable GPU rasterization -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, user-scalable=0, maximum-scale=1, minimum-scale=1">
  <title>Moberlinity</title>

  
   <style>
    body { 
      margin: 0;
      padding: 0; 
    }
    path {
      pointer-events: none
    }
    #app { 
      position: absolute;
      height: 100%;
      top: 51;
      bottom: 0;
      width: 100%;
    }
    .leaflet-container {
      cursor: default;
    }
    .leaflet-marker-icon {
      cursor: default;
    }
    .leaflet-marker-draggable:hover{
      cursor: -webkit-grab;
    }
    .leaflet-marker-draggable:active{
      cursor: -webkit-grabbing;
    }
    .distance-icon {
      border-radius: 10px;
      background: #fff;
      color: #1a25b9;
      text-align: center;
      font-size: 9px;
      display: inline-block;
      border: 2px solid #1a25b9;
    }

    .initializer {
      height: 40px; 
      width: 200px; 
      position: fixed; 
      background: #16c8ce;
      text-transform: uppercase; 
      color: white;
      border-radius: 2px;
      font-size: 16px;
      border: 0px #12a3a5;
      bottom: 0; 
      right: 0; 
      margin-bottom: 60px; 
      margin-right: 60px; 
      z-index: 1000
     -webkit-box-shadow: 10px 7px 14px 6px rgba(87,83,87,0.87);
      -moz-box-shadow: 10px 7px 14px 6px rgba(87,83,87,0.87);
      box-shadow: 10px 7px 14px 6px rgba(87,83,87,0.87);
    }
   </style>

</head>
<body>
<div id="app"></div>
<button onclick="run()" class="initializer"> Start simulation</button>

<script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
<script src='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.css' rel='stylesheet' />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>

<link href='https://www.mapbox.com/base/latest/base.css' rel='stylesheet' />

<script> 
  function Vehicle(location, status, battery) {
    this.id = getUID();
    this.location = location;
    this.status = status;
    this.battery = battery;
  }

  function Citizen(location, destination, vehicle) {
    this.id = getUID();
    this.vehicle = vehicle;
    this.location = location;
    this.destination = destination;
  }

  function Place(location) {
    this.id = getUID();
    this.location = location;
  }

  function Ride(simulationId, citizen, vehicle, finalLocation, duration) {
    this.id = getUID();
    this.citizen = citizen;
    this.vehicle = vehicle;
    this.finalLocation = finalLocation;
    this.duration = duration;
    this.simulationId = simulationId;
  }

  function Simulation(rides) {
    this.id = getUID();
    this.rides = rides;
  }

  const layers = {
    tile: null,
    centralMarker: null,
    circleArea: null,
    simulationPaths: [],
    simulationMarkers: [],
    ridesDuration: []
  }

  const runningIntervalsAndTimeouts = {
    rideEnd: [],
    rideAnimation: [],
    rideStart: null,
    simulationEnd: null
  }

  let totalSimulationDuration = 0;
  let finishSimulation = null;

  let maxSpeed = 45
  let numberOfVehicles;
  let numberOfCitizens;
  let initialCoordenates;
  let map;
  let currentRadius = 5; // kilometers
  let bufferedPoints;
  let currentSimulation;
  let onSimulation = false;
  const vehicles = [];
  const places = [];
  const citizens = [];
  const paths = [];
  const rides = [];
  const pathColors = [ '#815da6', '#599ba9', '#54bd36', '#530101', '#add5c5', '#919b30', '#cd7d84', '#855c51', '#f011ed', '#b54a71', '#6294e3' ];

  /**
   * Generates a random unique ID
   * @return string - Unique ID (non RFC4122 compliant)
   */
  function getUID() {
    return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
  }
  
  /**
   * Creates map and sets central marker object
   */
  (function createMap() {
    L.mapbox.accessToken = 'pk.eyJ1IjoianVhbmVjYWJlbGxvYiIsImEiOiJjajRqdXI1bjEwbnZwMnFvNzlsZDN1MzliIn0.BRkacCy_B0Yvz-6nR8wYuQ';
    map = L.mapbox.map('app').setView([51.505, -0.09], 13);
    layers.tile = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
      attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
      maxZoom: 18,
      id: 'mapbox.streets',
      accessToken: L.mapbox.accessToken
    });
    map.addLayer(layers.tile);
    layers.centralMarker = L.marker(new L.LatLng(51.505, -0.09), {
      icon: L.mapbox.marker.icon({
          'marker-color': '#00704A',
          'title': 'Entry point',
          'marker-size': 'large',
          'marker-symbol': 'marker-stroked'
      }),
      draggable: true,
      zIndexOffset: 999
    });
    layers.centralMarker.on('drag', () => {
      drawCircleArea();
    })
    map.addLayer(layers.centralMarker);
    map.on('click', onMapClick);
    drawCircleArea();
  })();

  /**
   *  Retrieves the point object of the central marker
   *  @return object - point object of the central marker
   */
  function getMarkerPoint() {
    const position = layers.centralMarker.getLatLng();
    const point = turf.point([ position.lng, position.lat ])
    return point;
  }

  /**
   * Generates a point buffer which has a circle form
   * @return object - polygon object that contains all the buffered points
   */
  function pointBuffer(point, radius, resolution, units) {
    let ring = []
    let resMultiple = 360/resolution;
    for (var i = 0; i < resolution; i++) {
      const spoke = turf.destination(point, radius, i*resMultiple, units);
      ring.push(spoke.geometry.coordinates);
    }
    if ((ring[0][0] !== ring[ring.length-1][0]) && (ring[0][1] != ring[ring.length-1][1])) {
      ring.push([ring[0][0], ring[0][1]]);
    }

    return turf.polygon([ring]);
  }

  /**
   * Adds a layer that contains the circle created by {@link pointBuffer} to the map
   */
  function drawCircleArea() {
    const point = getMarkerPoint();
    if (layers.circleArea !== null) {
      map.removeLayer(layers.circleArea);
    } 

    bufferedPoints = pointBuffer(point, currentRadius, 120, 'kilometers');
    bufferedPoints.properties = {
        'fill': 'blue',
        'fill-opacity': 0.05,
        'stroke': 'blue',
        'stroke-width': 2,
        'stroke-opacity': 0.7
    };
    layers.circleArea = L.mapbox.featureLayer().setGeoJSON(bufferedPoints);
    map.addLayer(layers.circleArea);
  }

  /**
   * Callback that triggers the repositioning of the central marker and rerenders the circle around it
   * @param e - event object
   */
  function onMapClick(e) {    
    initialCoordenates = [ e.latlng.lat, e.latlng.lng ];
    layers.centralMarker.setLatLng(initialCoordenates);
    map.setView(initialCoordenates, 13);
    drawCircleArea();
  }

  /**
   * Binds to the mousewheel event a function that adapts the area of the circle
   */
  $('.leaflet-marker-draggable').on('mousewheel',function(event){
    let wheelDelta= event.originalEvent.wheelDeltaY;
    if (currentRadius - wheelDelta * 0.001 >= 0.2 && currentRadius - wheelDelta * 0.001 <= 8 && !onSimulation) {
      currentRadius = currentRadius - wheelDelta * 0.001;
      drawCircleArea();
    }

    event.stopPropagation();
  });

  /** 
   * Takes a ffeature collection and based on the type it belongs adds properties to it and then adds it to the map as a layer
   * @param featureCollection - an object of type featureCollection that holds all features
   * @param type - string which could be of type 'vehicles', 'citizens', or 'places'
   */
  function updateSimulationMarkersProperties(featureCollection, type) {
    turf.featureEach(featureCollection, (currentFeature) => {
      switch (type) {
      case 'vehicles':
        currentFeature.properties['marker-color'] = '#ffe100'
        currentFeature.properties['title'] = `Vehicle at [${currentFeature.geometry.coordinates[0]}, ${currentFeature.geometry.coordinates[1]}]`;
        currentFeature.properties['marker-size'] = 'small';
        currentFeature.properties['marker-symbol'] = 'car';
        vehicles.push(new Vehicle(currentFeature, 'idle', 0));
        currentFeature.properties['id'] = vehicles[vehicles.length - 1].id;

        break;
      case 'citizens':
        currentFeature.properties['marker-color'] = '#00ff11'
        currentFeature.properties['title'] = `Citizen at [${currentFeature.geometry.coordinates[0]}, ${currentFeature.geometry.coordinates[1]}]`;
        currentFeature.properties['marker-size'] = 'small';
        currentFeature.properties['marker-symbol'] = 'pitch';
        citizens.push(new Citizen(currentFeature, null, null))
        currentFeature.properties['id'] = citizens[citizens.length - 1].id;
        break;
      case 'places':
        currentFeature.properties['marker-color'] = '#ff0000'
        currentFeature.properties['title'] = `Place at [${currentFeature.geometry.coordinates[0]}, ${currentFeature.geometry.coordinates[1]}]`;
        currentFeature.properties['marker-size'] = 'small';
        places.push(new Place(currentFeature));
        currentFeature.properties['id'] = places[places.length - 1].id;
        break;
      default:
        break;
      }
    });

    layers.simulationMarkers.push(L.mapbox.featureLayer().setGeoJSON(featureCollection));
    layers.simulationMarkers[layers.simulationMarkers.length - 1].on('mouseover', (e) => {
        e.layer.openPopup();
      })
      .on('mouseout', (e) => {
        e.layer.closePopup();
      });
    map.addLayer(layers.simulationMarkers[layers.simulationMarkers.length - 1]);
  }

  /**
   * Generates random markers scattered around the circle area 
   */
  function generateMarkers(number, type) {
    let featureCollection = turf.random('point', number, {
      bbox: turf.bbox(bufferedPoints)  
    });
    let j = 0;
    let insideCircle = turf.within(featureCollection, turf.featureCollection([bufferedPoints]));
    while (insideCircle.features.length < number && j < 50) {
      featureCollection = turf.random('point', number - insideCircle.features.length, {
        bbox: turf.bbox(bufferedPoints)  
      });

      insideCircle = turf.featureCollection([
        ...insideCircle.features, 
        ...turf.within(featureCollection, turf.featureCollection([bufferedPoints])).features
      ]);

      j = j + 1;
    }
    updateSimulationMarkersProperties(insideCircle, type);
  }

  /**
   * Simulates a ride
   * @param citizen - object containing the citizen that is moving
   * @param place - object containing  the destination of the citizen
   * @param iteration - number that holds the iteration number of the simulation
   * @param timeOfSimulationStart - number that hold the time in seconds of the simulation's start
   */
  function simulateRide(citizen, place, iteration, numberOfSimulations, timeOfSimulationStart) {
    // update destination
    let timeOfRideStart = moment().seconds();

    const vehicleLocations = vehicles.filter(vehicle => vehicle.status === 'idle').map(vehicle => vehicle.location);


    if (vehicleLocations.length === 0 || citizen.destination !== null) {
      return false;
    }

    // find nearest vehicle
    const nearestVehicleFeature = turf.nearest(citizen.location, turf.featureCollection(vehicleLocations))
    const nearestVehicle = vehicles.filter(vehicle => vehicle.location === nearestVehicleFeature)[0];
    nearestVehicle.status = 'on-the-road';
    citizen.destination = _.cloneDeep(place.location);
    citizen.vehicle = _.cloneDeep(nearestVehicle);
    // road from his place to vehicle
    const citizenCoordinates = citizen.location.geometry.coordinates;
    const vehicleCoordinates = nearestVehicleFeature.geometry.coordinates;
    
    let startEnd = `${citizenCoordinates[0]},${citizenCoordinates[1]};${vehicleCoordinates[0]},${vehicleCoordinates[1]}`;

    const directionsCitizenVehicleAPI = `https://api.mapbox.com/directions/v5/mapbox/walking/${startEnd}.json?geometries=geojson&access_token=${L.mapbox.accessToken}`;

    $.get(directionsCitizenVehicleAPI, (data) => {
      let coordsAB = data.routes[0].geometry.coordinates;
      coordsAB.unshift(citizenCoordinates);
      coordsAB.push(vehicleCoordinates);

      // duration from initial location to vehicle
      let totalRideDuration = data.routes[0].duration;
      const placeCoordinates = place.location.geometry.coordinates;
      startEnd = `${vehicleCoordinates[0]},${vehicleCoordinates[1]};${placeCoordinates[0]},${placeCoordinates[1]}`;
      const directionsVehiclePlaceAPI = `https://api.mapbox.com/directions/v5/mapbox/driving/${startEnd}.json?geometries=geojson&access_token=${L.mapbox.accessToken}`;
      $.get(directionsVehiclePlaceAPI, (data) => {
        let coordsBC = data.routes[0].geometry.coordinates;
        coordsBC.unshift(...coordsAB);
        coordsBC.push(placeCoordinates);

        // duration from vehicle to final location
        totalRideDuration = totalRideDuration + data.routes[0].duration;
        let relativeDurationToStartOfSimulation =  timeOfRideStart - timeOfSimulationStart + totalRideDuration;

        if (relativeDurationToStartOfSimulation > totalSimulationDuration) {
          totalSimulationDuration = relativeDurationToStartOfSimulation;
          if (runningIntervalsAndTimeouts.simulationEnd !== null) {
            clearTimeout(runningIntervalsAndTimeouts.simulationEnd);
          }

          runningIntervalsAndTimeouts.simulationEnd = setTimeout(() => {            
            finalizeSimulation();
            console.log('>>>>>> SIMULATION ENDED');
          }, (totalRideDuration * 100) + 1000);
        }

        paths.push(turf.lineString(coordsBC, {
          "name": `Iteration ${iteration} path`,
          "duration": totalRideDuration, 
          "stroke": pathColors[iteration % 10],
          "stroke-width": 4,
          "opacity": 1
        }));

        layers.simulationPaths.push(L.mapbox.featureLayer()
          .setGeoJSON(turf.featureCollection(paths))
          .on('mouseover', (e) => {
            e.layer.openPopup();
          })
          .on('mouseleave', (e) => {
            e.layer.closePopup();
          }))

        let simulationPathLayerIndex = layers.simulationPaths.length - 1;

        map.addLayer(layers.simulationPaths[layers.simulationPaths.length - 1]);

        let totalRideDurationParsed = moment.duration(totalRideDuration, 'seconds').humanize()
        
        layers.ridesDuration.push(L.marker([ coordsBC[ parseInt(coordsBC.length * 0.5)][1],
          coordsBC[ parseInt(coordsBC.length * 0.5) ][0] ], {
            icon: L.divIcon({
              className: 'distance-icon',
              html: `<strong style="color: ${pathColors[iteration]}">${totalRideDurationParsed}</strong>`,
              iconSize: [60, 23]
            })
          })
        )


        let subleg = 0;
        const pathUpdater = setInterval((pathEntry) => {
          subleg = subleg + 1;
          let citizenMarkers = layers.simulationMarkers[1].getGeoJSON();
          let totalPathDistance = turf.lineDistance(paths[pathEntry]);
          let getNewPoint = turf.along(paths[pathEntry], totalPathDistance / 100 * subleg);

          citizenMarkers.features.filter(feature => feature.properties.id === citizen.id)[0].geometry.coordinates = getNewPoint.geometry.coordinates;
          layers.simulationMarkers[1].setGeoJSON(citizenMarkers).addTo(map);
        }, (totalRideDuration * 100) / 100, paths.length - 1);

        runningIntervalsAndTimeouts.rideAnimation.push(pathUpdater);

        const ridesDurationLayerIndex = layers.ridesDuration.length - 1;

        map.addLayer(layers.ridesDuration[ridesDurationLayerIndex]);
        runningIntervalsAndTimeouts.rideEnd.push(setTimeout(() => {
          console.log('>>>>>>> RIDE CONCLUDED')
          console.log('======================')
          console.log('Citizen moved from ', citizen.location, ' to ', citizen.destination);
          console.log('Nearest vehicle founded at ', nearestVehicle.location);
          console.log('======================')
          rides.push(new Ride(currentSimulation.id, _.cloneDeep(citizen), _.cloneDeep(nearestVehicle), _.cloneDeep(place), totalRideDuration));
          citizen.destination = null;
          citizen.location = place.location;
          nearestVehicle.location = place.location;
          nearestVehicle.status = 'idle';
          let vehicleMarkers = layers.simulationMarkers[0].getGeoJSON();
          clearInterval(pathUpdater);
          vehicleMarkers.features.filter(feature => feature.properties.id === nearestVehicle.id)[0].geometry.coordinates = nearestVehicle.location.geometry.coordinates;
          layers.simulationMarkers[0].setGeoJSON(vehicleMarkers).addTo(map);
          let citizenMarkers = layers.simulationMarkers[1].getGeoJSON();
          citizenMarkers.features.filter(feature => feature.properties.id === citizen.id)[0].geometry.coordinates = citizen.location.geometry.coordinates;
          layers.simulationMarkers[1].setGeoJSON(citizenMarkers).addTo(map);
          map.removeLayer(layers.ridesDuration[ridesDurationLayerIndex]);
          layers.simulationPaths[simulationPathLayerIndex].clearLayers();
        }, totalRideDuration * 100)); // to speed up everything it's using seconds as milliseconds

      });
    });

    return true;
  }

  /**
   * Starts the simulation
   * @todo take the id and load the simulation based on the id
   */
  function startSimulation(id) {
    console.log('>>>>> SIMULATION STARTS');
    currentSimulation = new Simulation(null);
    // let timeOfDay = $('#timeOfDay').value();
    let getRandomPlaceIndex = function () {
      return Math.floor(Math.random() * (places.length));
    };

    let numberOfSimulations = Math.floor(Math.random() * (7200 - 3600)) + 3600;
    let timeOfSimulationStart = moment().seconds();
    for (var i = 0; i < numberOfSimulations; i++) {
      citizenIndex = i % citizens.length;
      
      setTimeout((citizen, place, iteration) => {
        simulateRide(citizen, place, iteration, numberOfSimulations, timeOfSimulationStart);
      }, Math.floor(Math.random() * (getMaxTime() - getMinTime())) + getMinTime(), citizens[citizenIndex], places[getRandomPlaceIndex()], i);
    }
  }

  /**
   * Runs a simulation
   */
  function run() {
    resetMap();
    prepareSimulation();
    startSimulation();
  }

  /**
   * Clears all layers but the tile layer, circle polygon and the central marker layer of the existing map and sets all simulation arrays to 0
   */
  function resetMap() {
    layers.simulationMarkers.forEach((layer) => {
      layer.clearLayers();
    });

    layers.simulationPaths.forEach((layer) => {
      layer.clearLayers();
    });

    layers.ridesDuration.forEach((layer) => {
      map.removeLayer(layer);
    });

    clearAllIntervalsAndTimeouts();
    currentSimulation = null;
    onSimulation = false;
    
    vehicles.length = 0;
    places.length = 0;
    citizens.length = 0;
    paths.length = 0;
    rides.length = 0;
    layers.simulationPaths.length = 0;
    layers.simulationMarkers.length = 0;
    layers.ridesDuration.length = 0;
    paths.length = 0;
  }

  /**
   * Prepares the markers of the simulation
   * TODO: If a simulation has been selected, load it from localStorage
   */
  function prepareSimulation() {
    numberOfVehicles = prompt('Please enter the number of vehicles', '30');
    numberOfCitizens = prompt('Please enter the number of citizens', '10');
    generateMarkers(numberOfVehicles, 'vehicles');
    generateMarkers(numberOfCitizens, 'citizens');
    generateMarkers(Math.ceil(Math.random() * (100 - 50)) + 50, 'places');
    onSimulation = true;
  }

  /**
   * Clears all the timeouts of a simulation
   */
  function clearAllIntervalsAndTimeouts() {
    if (runningIntervalsAndTimeouts.rideEnd.length === 0) {
      return;
    }

    if (runningIntervalsAndTimeouts.simulationEnd !== null) {
      clearTimeout(runningIntervalsAndTimeouts.simulationEnd)
      runningIntervalsAndTimeouts.simulationEnd = null;
    }

    runningIntervalsAndTimeouts.rideAnimation.map(intervalId => clearInterval(intervalId));
    runningIntervalsAndTimeouts.rideEnd.map(timeout => clearTimeout(timeout));
    console.log('>>>> All timeouts have been cleared');
    runningIntervalsAndTimeouts.rideAnimation.length = 0;
    runningIntervalsAndTimeouts.rideEnd.length = 0;
  }

  /**
   * Takes a string and returns a number simulating the max numbers of seconds that can go by without a citizen using a vehicle
   * @param timeOfDay - string with values of either 'morning', 'afternoon', or 'evening'
   * @return number - max numbers of seconds that can go by without a citizen using a vehicle
   */
  function getMaxTime(timeOfDay) {
    switch(timeOfDay) {
    case 'morning':
      return 10;
    case 'afternoon':
      return 100;
    case 'evening':
      return 1000;
    default: 
      return 500;
    }
  }

  /**
   * Takes a string and returns a number simulating the min numbers of seconds that can go by without a citizen using a vehicle
   * @param timeOfDay - string with values of either 'morning', 'afternoon', or 'evening'
   * @return number - min numbers of seconds that can go by without a citizen using a vehicle
   */
  function getMinTime(timeOfDay) {
    switch(timeOfDay) {
    case 'morning':
      return 5;
    case 'afternoon':
      return 50;
    case 'evening':
      return 500;
    default: 
      return 250;
    }
  }

  /**
   * Finalizes a simulation by storing the simulation on localStorage and setting the flag of onSimulation to false
   */
  function finalizeSimulation() {
    onSimulation = false;
    currentSimulation.rides = rides;
    window.localStorage.setItem(`simulation-${currentSimulation.id}-${moment.utc()}`, JSON.stringify(currentSimulation, null, 4));
  }

  </script>
</body>
</html>
